// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package verifreg

import (
	"fmt"
	"io"
	"math"
	"sort"

	abi "github.com/filecoin-project/go-state-types/abi"
	exitcode "github.com/filecoin-project/go-state-types/exitcode"
	cid "github.com/ipfs/go-cid"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf
var _ = cid.Undef
var _ = math.E
var _ = sort.Sort

var lengthBufState = []byte{134}

func (t *State) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufState); err != nil {
		return err
	}

	// t.RootKey (address.Address) (struct)
	if err := t.RootKey.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Verifiers (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Verifiers); err != nil {
		return xerrors.Errorf("failed to write cid field t.Verifiers: %w", err)
	}

	// t.RemoveDataCapProposalIDs (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.RemoveDataCapProposalIDs); err != nil {
		return xerrors.Errorf("failed to write cid field t.RemoveDataCapProposalIDs: %w", err)
	}

	// t.Allocations (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Allocations); err != nil {
		return xerrors.Errorf("failed to write cid field t.Allocations: %w", err)
	}

	// t.NextAllocationId (verifreg.AllocationId) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.NextAllocationId)); err != nil {
		return err
	}

	// t.Claims (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Claims); err != nil {
		return xerrors.Errorf("failed to write cid field t.Claims: %w", err)
	}

	return nil
}

func (t *State) UnmarshalCBOR(r io.Reader) (err error) {
	*t = State{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.RootKey (address.Address) (struct)

	{

		if err := t.RootKey.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.RootKey: %w", err)
		}

	}
	// t.Verifiers (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Verifiers: %w", err)
		}

		t.Verifiers = c

	}
	// t.RemoveDataCapProposalIDs (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.RemoveDataCapProposalIDs: %w", err)
		}

		t.RemoveDataCapProposalIDs = c

	}
	// t.Allocations (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Allocations: %w", err)
		}

		t.Allocations = c

	}
	// t.NextAllocationId (verifreg.AllocationId) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.NextAllocationId = AllocationId(extra)

	}
	// t.Claims (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Claims: %w", err)
		}

		t.Claims = c

	}
	return nil
}

var lengthBufAddVerifierParams = []byte{130}

func (t *AddVerifierParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufAddVerifierParams); err != nil {
		return err
	}

	// t.Address (address.Address) (struct)
	if err := t.Address.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Allowance (big.Int) (struct)
	if err := t.Allowance.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *AddVerifierParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = AddVerifierParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Address (address.Address) (struct)

	{

		if err := t.Address.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Address: %w", err)
		}

	}
	// t.Allowance (big.Int) (struct)

	{

		if err := t.Allowance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Allowance: %w", err)
		}

	}
	return nil
}

var lengthBufAddVerifiedClientParams = []byte{130}

func (t *AddVerifiedClientParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufAddVerifiedClientParams); err != nil {
		return err
	}

	// t.Address (address.Address) (struct)
	if err := t.Address.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Allowance (big.Int) (struct)
	if err := t.Allowance.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *AddVerifiedClientParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = AddVerifiedClientParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Address (address.Address) (struct)

	{

		if err := t.Address.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Address: %w", err)
		}

	}
	// t.Allowance (big.Int) (struct)

	{

		if err := t.Allowance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Allowance: %w", err)
		}

	}
	return nil
}

var lengthBufUseBytesParams = []byte{130}

func (t *UseBytesParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufUseBytesParams); err != nil {
		return err
	}

	// t.Address (address.Address) (struct)
	if err := t.Address.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DealSize (big.Int) (struct)
	if err := t.DealSize.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *UseBytesParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = UseBytesParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Address (address.Address) (struct)

	{

		if err := t.Address.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Address: %w", err)
		}

	}
	// t.DealSize (big.Int) (struct)

	{

		if err := t.DealSize.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.DealSize: %w", err)
		}

	}
	return nil
}

var lengthBufRestoreBytesParams = []byte{130}

func (t *RestoreBytesParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRestoreBytesParams); err != nil {
		return err
	}

	// t.Address (address.Address) (struct)
	if err := t.Address.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DealSize (big.Int) (struct)
	if err := t.DealSize.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RestoreBytesParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RestoreBytesParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Address (address.Address) (struct)

	{

		if err := t.Address.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Address: %w", err)
		}

	}
	// t.DealSize (big.Int) (struct)

	{

		if err := t.DealSize.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.DealSize: %w", err)
		}

	}
	return nil
}

var lengthBufRemoveDataCapParams = []byte{132}

func (t *RemoveDataCapParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveDataCapParams); err != nil {
		return err
	}

	// t.VerifiedClientToRemove (address.Address) (struct)
	if err := t.VerifiedClientToRemove.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DataCapAmountToRemove (big.Int) (struct)
	if err := t.DataCapAmountToRemove.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.VerifierRequest1 (verifreg.RemoveDataCapRequest) (struct)
	if err := t.VerifierRequest1.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.VerifierRequest2 (verifreg.RemoveDataCapRequest) (struct)
	if err := t.VerifierRequest2.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RemoveDataCapParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveDataCapParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.VerifiedClientToRemove (address.Address) (struct)

	{

		if err := t.VerifiedClientToRemove.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.VerifiedClientToRemove: %w", err)
		}

	}
	// t.DataCapAmountToRemove (big.Int) (struct)

	{

		if err := t.DataCapAmountToRemove.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.DataCapAmountToRemove: %w", err)
		}

	}
	// t.VerifierRequest1 (verifreg.RemoveDataCapRequest) (struct)

	{

		if err := t.VerifierRequest1.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.VerifierRequest1: %w", err)
		}

	}
	// t.VerifierRequest2 (verifreg.RemoveDataCapRequest) (struct)

	{

		if err := t.VerifierRequest2.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.VerifierRequest2: %w", err)
		}

	}
	return nil
}

var lengthBufRemoveDataCapReturn = []byte{130}

func (t *RemoveDataCapReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveDataCapReturn); err != nil {
		return err
	}

	// t.VerifiedClient (address.Address) (struct)
	if err := t.VerifiedClient.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DataCapRemoved (big.Int) (struct)
	if err := t.DataCapRemoved.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RemoveDataCapReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveDataCapReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.VerifiedClient (address.Address) (struct)

	{

		if err := t.VerifiedClient.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.VerifiedClient: %w", err)
		}

	}
	// t.DataCapRemoved (big.Int) (struct)

	{

		if err := t.DataCapRemoved.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.DataCapRemoved: %w", err)
		}

	}
	return nil
}

var lengthBufRemoveExpiredAllocationsParams = []byte{130}

func (t *RemoveExpiredAllocationsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveExpiredAllocationsParams); err != nil {
		return err
	}

	// t.Client (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Client)); err != nil {
		return err
	}

	// t.AllocationIds ([]verifreg.AllocationId) (slice)
	if len(t.AllocationIds) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.AllocationIds was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.AllocationIds))); err != nil {
		return err
	}
	for _, v := range t.AllocationIds {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}
	return nil
}

func (t *RemoveExpiredAllocationsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveExpiredAllocationsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Client (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Client = abi.ActorID(extra)

	}
	// t.AllocationIds ([]verifreg.AllocationId) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.AllocationIds: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.AllocationIds = make([]AllocationId, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.AllocationIds slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.AllocationIds was not a uint, instead got %d", maj)
		}

		t.AllocationIds[i] = AllocationId(val)
	}

	return nil
}

var lengthBufRemoveExpiredAllocationsReturn = []byte{131}

func (t *RemoveExpiredAllocationsReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveExpiredAllocationsReturn); err != nil {
		return err
	}

	// t.Considered ([]verifreg.AllocationId) (slice)
	if len(t.Considered) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Considered was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Considered))); err != nil {
		return err
	}
	for _, v := range t.Considered {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}

	// t.Results (verifreg.BatchReturn) (struct)
	if err := t.Results.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DataCapRecovered (big.Int) (struct)
	if err := t.DataCapRecovered.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RemoveExpiredAllocationsReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveExpiredAllocationsReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Considered ([]verifreg.AllocationId) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Considered: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Considered = make([]AllocationId, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.Considered slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.Considered was not a uint, instead got %d", maj)
		}

		t.Considered[i] = AllocationId(val)
	}

	// t.Results (verifreg.BatchReturn) (struct)

	{

		if err := t.Results.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Results: %w", err)
		}

	}
	// t.DataCapRecovered (big.Int) (struct)

	{

		if err := t.DataCapRecovered.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.DataCapRecovered: %w", err)
		}

	}
	return nil
}

var lengthBufBatchReturn = []byte{130}

func (t *BatchReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBatchReturn); err != nil {
		return err
	}

	// t.SuccessCount (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SuccessCount)); err != nil {
		return err
	}

	// t.FailCodes ([]verifreg.FailCode) (slice)
	if len(t.FailCodes) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.FailCodes was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.FailCodes))); err != nil {
		return err
	}
	for _, v := range t.FailCodes {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *BatchReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BatchReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SuccessCount (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.SuccessCount = uint64(extra)

	}
	// t.FailCodes ([]verifreg.FailCode) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.FailCodes: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.FailCodes = make([]FailCode, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v FailCode
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.FailCodes[i] = v
	}

	return nil
}

var lengthBufClaimAllocationsParams = []byte{130}

func (t *ClaimAllocationsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufClaimAllocationsParams); err != nil {
		return err
	}

	// t.Sectors ([]verifreg.SectorAllocationClaim) (slice)
	if len(t.Sectors) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Sectors was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Sectors))); err != nil {
		return err
	}
	for _, v := range t.Sectors {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}

	// t.AllOrNothing (bool) (bool)
	if err := cbg.WriteBool(w, t.AllOrNothing); err != nil {
		return err
	}
	return nil
}

func (t *ClaimAllocationsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ClaimAllocationsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Sectors ([]verifreg.SectorAllocationClaim) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Sectors: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Sectors = make([]SectorAllocationClaim, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v SectorAllocationClaim
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Sectors[i] = v
	}

	// t.AllOrNothing (bool) (bool)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}
	if maj != cbg.MajOther {
		return fmt.Errorf("booleans must be major type 7")
	}
	switch extra {
	case 20:
		t.AllOrNothing = false
	case 21:
		t.AllOrNothing = true
	default:
		return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
	}
	return nil
}

var lengthBufClaimAllocationsReturn = []byte{130}

func (t *ClaimAllocationsReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufClaimAllocationsReturn); err != nil {
		return err
	}

	// t.BatchInfo (verifreg.BatchReturn) (struct)
	if err := t.BatchInfo.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.ClaimedSpace (big.Int) (struct)
	if err := t.ClaimedSpace.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *ClaimAllocationsReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ClaimAllocationsReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.BatchInfo (verifreg.BatchReturn) (struct)

	{

		if err := t.BatchInfo.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.BatchInfo: %w", err)
		}

	}
	// t.ClaimedSpace (big.Int) (struct)

	{

		if err := t.ClaimedSpace.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.ClaimedSpace: %w", err)
		}

	}
	return nil
}

var lengthBufGetClaimsParams = []byte{130}

func (t *GetClaimsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufGetClaimsParams); err != nil {
		return err
	}

	// t.Provider (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Provider)); err != nil {
		return err
	}

	// t.ClaimIds ([]verifreg.ClaimId) (slice)
	if len(t.ClaimIds) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.ClaimIds was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.ClaimIds))); err != nil {
		return err
	}
	for _, v := range t.ClaimIds {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}
	return nil
}

func (t *GetClaimsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = GetClaimsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Provider (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Provider = abi.ActorID(extra)

	}
	// t.ClaimIds ([]verifreg.ClaimId) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.ClaimIds: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.ClaimIds = make([]ClaimId, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.ClaimIds slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.ClaimIds was not a uint, instead got %d", maj)
		}

		t.ClaimIds[i] = ClaimId(val)
	}

	return nil
}

var lengthBufGetClaimsReturn = []byte{130}

func (t *GetClaimsReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufGetClaimsReturn); err != nil {
		return err
	}

	// t.BatchInfo (verifreg.BatchReturn) (struct)
	if err := t.BatchInfo.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Claims ([]verifreg.Claim) (slice)
	if len(t.Claims) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Claims was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Claims))); err != nil {
		return err
	}
	for _, v := range t.Claims {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *GetClaimsReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = GetClaimsReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.BatchInfo (verifreg.BatchReturn) (struct)

	{

		if err := t.BatchInfo.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.BatchInfo: %w", err)
		}

	}
	// t.Claims ([]verifreg.Claim) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Claims: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Claims = make([]Claim, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v Claim
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Claims[i] = v
	}

	return nil
}

var lengthBufUniversalReceiverParams = []byte{130}

func (t *UniversalReceiverParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufUniversalReceiverParams); err != nil {
		return err
	}

	// t.Type_ (verifreg.ReceiverType) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Type_)); err != nil {
		return err
	}

	// t.Payload ([]uint8) (slice)
	if len(t.Payload) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.Payload was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.Payload))); err != nil {
		return err
	}

	if _, err := cw.Write(t.Payload[:]); err != nil {
		return err
	}
	return nil
}

func (t *UniversalReceiverParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = UniversalReceiverParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Type_ (verifreg.ReceiverType) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Type_ = ReceiverType(extra)

	}
	// t.Payload ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.Payload: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.Payload = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.Payload[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufAllocationsResponse = []byte{131}

func (t *AllocationsResponse) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufAllocationsResponse); err != nil {
		return err
	}

	// t.AllocationResults (verifreg.BatchReturn) (struct)
	if err := t.AllocationResults.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.ExtensionResults (verifreg.BatchReturn) (struct)
	if err := t.ExtensionResults.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.NewAllocations ([]verifreg.AllocationId) (slice)
	if len(t.NewAllocations) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.NewAllocations was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.NewAllocations))); err != nil {
		return err
	}
	for _, v := range t.NewAllocations {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}
	return nil
}

func (t *AllocationsResponse) UnmarshalCBOR(r io.Reader) (err error) {
	*t = AllocationsResponse{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.AllocationResults (verifreg.BatchReturn) (struct)

	{

		if err := t.AllocationResults.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.AllocationResults: %w", err)
		}

	}
	// t.ExtensionResults (verifreg.BatchReturn) (struct)

	{

		if err := t.ExtensionResults.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.ExtensionResults: %w", err)
		}

	}
	// t.NewAllocations ([]verifreg.AllocationId) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.NewAllocations: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.NewAllocations = make([]AllocationId, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.NewAllocations slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.NewAllocations was not a uint, instead got %d", maj)
		}

		t.NewAllocations[i] = AllocationId(val)
	}

	return nil
}

var lengthBufExtendClaimTermsParams = []byte{129}

func (t *ExtendClaimTermsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufExtendClaimTermsParams); err != nil {
		return err
	}

	// t.Terms ([]verifreg.ClaimTerm) (slice)
	if len(t.Terms) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Terms was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Terms))); err != nil {
		return err
	}
	for _, v := range t.Terms {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *ExtendClaimTermsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ExtendClaimTermsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Terms ([]verifreg.ClaimTerm) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Terms: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Terms = make([]ClaimTerm, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v ClaimTerm
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Terms[i] = v
	}

	return nil
}

var lengthBufExtendClaimTermsReturn = []byte{130}

func (t *ExtendClaimTermsReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufExtendClaimTermsReturn); err != nil {
		return err
	}

	// t.SuccessCount (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SuccessCount)); err != nil {
		return err
	}

	// t.FailCodes ([]verifreg.FailCode) (slice)
	if len(t.FailCodes) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.FailCodes was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.FailCodes))); err != nil {
		return err
	}
	for _, v := range t.FailCodes {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *ExtendClaimTermsReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ExtendClaimTermsReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SuccessCount (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.SuccessCount = uint64(extra)

	}
	// t.FailCodes ([]verifreg.FailCode) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.FailCodes: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.FailCodes = make([]FailCode, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v FailCode
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.FailCodes[i] = v
	}

	return nil
}

var lengthBufRemoveExpiredClaimsParams = []byte{130}

func (t *RemoveExpiredClaimsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveExpiredClaimsParams); err != nil {
		return err
	}

	// t.Provider (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Provider)); err != nil {
		return err
	}

	// t.ClaimIds ([]verifreg.ClaimId) (slice)
	if len(t.ClaimIds) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.ClaimIds was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.ClaimIds))); err != nil {
		return err
	}
	for _, v := range t.ClaimIds {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}
	return nil
}

func (t *RemoveExpiredClaimsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveExpiredClaimsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Provider (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Provider = abi.ActorID(extra)

	}
	// t.ClaimIds ([]verifreg.ClaimId) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.ClaimIds: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.ClaimIds = make([]ClaimId, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.ClaimIds slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.ClaimIds was not a uint, instead got %d", maj)
		}

		t.ClaimIds[i] = ClaimId(val)
	}

	return nil
}

var lengthBufRemoveExpiredClaimsReturn = []byte{130}

func (t *RemoveExpiredClaimsReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveExpiredClaimsReturn); err != nil {
		return err
	}

	// t.Considered ([]verifreg.AllocationId) (slice)
	if len(t.Considered) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Considered was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Considered))); err != nil {
		return err
	}
	for _, v := range t.Considered {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}

	// t.Results (verifreg.BatchReturn) (struct)
	if err := t.Results.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RemoveExpiredClaimsReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveExpiredClaimsReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Considered ([]verifreg.AllocationId) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Considered: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Considered = make([]AllocationId, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.Considered slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.Considered was not a uint, instead got %d", maj)
		}

		t.Considered[i] = AllocationId(val)
	}

	// t.Results (verifreg.BatchReturn) (struct)

	{

		if err := t.Results.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Results: %w", err)
		}

	}
	return nil
}

var lengthBufRemoveDataCapRequest = []byte{130}

func (t *RemoveDataCapRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveDataCapRequest); err != nil {
		return err
	}

	// t.Verifier (address.Address) (struct)
	if err := t.Verifier.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.VerifierSignature (crypto.Signature) (struct)
	if err := t.VerifierSignature.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RemoveDataCapRequest) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveDataCapRequest{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Verifier (address.Address) (struct)

	{

		if err := t.Verifier.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Verifier: %w", err)
		}

	}
	// t.VerifierSignature (crypto.Signature) (struct)

	{

		if err := t.VerifierSignature.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.VerifierSignature: %w", err)
		}

	}
	return nil
}

var lengthBufRemoveDataCapProposal = []byte{131}

func (t *RemoveDataCapProposal) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRemoveDataCapProposal); err != nil {
		return err
	}

	// t.VerifiedClient (address.Address) (struct)
	if err := t.VerifiedClient.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DataCapAmount (big.Int) (struct)
	if err := t.DataCapAmount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RemovalProposalID (verifreg.RmDcProposalID) (struct)
	if err := t.RemovalProposalID.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RemoveDataCapProposal) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RemoveDataCapProposal{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.VerifiedClient (address.Address) (struct)

	{

		if err := t.VerifiedClient.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.VerifiedClient: %w", err)
		}

	}
	// t.DataCapAmount (big.Int) (struct)

	{

		if err := t.DataCapAmount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.DataCapAmount: %w", err)
		}

	}
	// t.RemovalProposalID (verifreg.RmDcProposalID) (struct)

	{

		if err := t.RemovalProposalID.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.RemovalProposalID: %w", err)
		}

	}
	return nil
}

var lengthBufRmDcProposalID = []byte{129}

func (t *RmDcProposalID) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRmDcProposalID); err != nil {
		return err
	}

	// t.ProposalID (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ProposalID)); err != nil {
		return err
	}

	return nil
}

func (t *RmDcProposalID) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RmDcProposalID{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.ProposalID (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.ProposalID = uint64(extra)

	}
	return nil
}

var lengthBufFailCode = []byte{130}

func (t *FailCode) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufFailCode); err != nil {
		return err
	}

	// t.Idx (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Idx)); err != nil {
		return err
	}

	// t.Code (exitcode.ExitCode) (int64)
	if t.Code >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Code)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.Code-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *FailCode) UnmarshalCBOR(r io.Reader) (err error) {
	*t = FailCode{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Idx (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Idx = uint64(extra)

	}
	// t.Code (exitcode.ExitCode) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.Code = exitcode.ExitCode(extraI)
	}
	return nil
}

var lengthBufSectorAllocationClaim = []byte{134}

func (t *SectorAllocationClaim) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufSectorAllocationClaim); err != nil {
		return err
	}

	// t.Client (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Client)); err != nil {
		return err
	}

	// t.AllocationId (verifreg.AllocationId) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.AllocationId)); err != nil {
		return err
	}

	// t.Data (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Data); err != nil {
		return xerrors.Errorf("failed to write cid field t.Data: %w", err)
	}

	// t.Size (abi.PaddedPieceSize) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Size)); err != nil {
		return err
	}

	// t.Sector (abi.SectorNumber) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Sector)); err != nil {
		return err
	}

	// t.SectorExpiry (abi.ChainEpoch) (int64)
	if t.SectorExpiry >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SectorExpiry)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.SectorExpiry-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *SectorAllocationClaim) UnmarshalCBOR(r io.Reader) (err error) {
	*t = SectorAllocationClaim{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Client (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Client = abi.ActorID(extra)

	}
	// t.AllocationId (verifreg.AllocationId) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.AllocationId = AllocationId(extra)

	}
	// t.Data (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Data: %w", err)
		}

		t.Data = c

	}
	// t.Size (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Size = abi.PaddedPieceSize(extra)

	}
	// t.Sector (abi.SectorNumber) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Sector = abi.SectorNumber(extra)

	}
	// t.SectorExpiry (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.SectorExpiry = abi.ChainEpoch(extraI)
	}
	return nil
}

var lengthBufClaim = []byte{136}

func (t *Claim) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufClaim); err != nil {
		return err
	}

	// t.Provider (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Provider)); err != nil {
		return err
	}

	// t.Client (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Client)); err != nil {
		return err
	}

	// t.Data (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Data); err != nil {
		return xerrors.Errorf("failed to write cid field t.Data: %w", err)
	}

	// t.Size (abi.PaddedPieceSize) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Size)); err != nil {
		return err
	}

	// t.TermMin (abi.ChainEpoch) (int64)
	if t.TermMin >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMin)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMin-1)); err != nil {
			return err
		}
	}

	// t.TermMax (abi.ChainEpoch) (int64)
	if t.TermMax >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMax)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMax-1)); err != nil {
			return err
		}
	}

	// t.TermStart (abi.ChainEpoch) (int64)
	if t.TermStart >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermStart)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermStart-1)); err != nil {
			return err
		}
	}

	// t.Sector (abi.SectorNumber) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Sector)); err != nil {
		return err
	}

	return nil
}

func (t *Claim) UnmarshalCBOR(r io.Reader) (err error) {
	*t = Claim{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 8 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Provider (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Provider = abi.ActorID(extra)

	}
	// t.Client (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Client = abi.ActorID(extra)

	}
	// t.Data (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Data: %w", err)
		}

		t.Data = c

	}
	// t.Size (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Size = abi.PaddedPieceSize(extra)

	}
	// t.TermMin (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMin = abi.ChainEpoch(extraI)
	}
	// t.TermMax (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMax = abi.ChainEpoch(extraI)
	}
	// t.TermStart (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermStart = abi.ChainEpoch(extraI)
	}
	// t.Sector (abi.SectorNumber) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Sector = abi.SectorNumber(extra)

	}
	return nil
}

var lengthBufClaimTerm = []byte{131}

func (t *ClaimTerm) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufClaimTerm); err != nil {
		return err
	}

	// t.Provider (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Provider)); err != nil {
		return err
	}

	// t.ClaimId (verifreg.ClaimId) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ClaimId)); err != nil {
		return err
	}

	// t.TermMax (abi.ChainEpoch) (int64)
	if t.TermMax >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMax)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMax-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *ClaimTerm) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ClaimTerm{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Provider (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Provider = abi.ActorID(extra)

	}
	// t.ClaimId (verifreg.ClaimId) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.ClaimId = ClaimId(extra)

	}
	// t.TermMax (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMax = abi.ChainEpoch(extraI)
	}
	return nil
}

var lengthBufClaimExtensionRequest = []byte{131}

func (t *ClaimExtensionRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufClaimExtensionRequest); err != nil {
		return err
	}

	// t.Provider (address.Address) (struct)
	if err := t.Provider.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Claim (verifreg.ClaimId) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Claim)); err != nil {
		return err
	}

	// t.TermMax (abi.ChainEpoch) (int64)
	if t.TermMax >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMax)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMax-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *ClaimExtensionRequest) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ClaimExtensionRequest{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Provider (address.Address) (struct)

	{

		if err := t.Provider.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Provider: %w", err)
		}

	}
	// t.Claim (verifreg.ClaimId) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Claim = ClaimId(extra)

	}
	// t.TermMax (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMax = abi.ChainEpoch(extraI)
	}
	return nil
}

var lengthBufAllocation = []byte{135}

func (t *Allocation) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufAllocation); err != nil {
		return err
	}

	// t.Client (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Client)); err != nil {
		return err
	}

	// t.Provider (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Provider)); err != nil {
		return err
	}

	// t.Data (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Data); err != nil {
		return xerrors.Errorf("failed to write cid field t.Data: %w", err)
	}

	// t.Size (abi.PaddedPieceSize) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Size)); err != nil {
		return err
	}

	// t.TermMin (abi.ChainEpoch) (int64)
	if t.TermMin >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMin)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMin-1)); err != nil {
			return err
		}
	}

	// t.TermMax (abi.ChainEpoch) (int64)
	if t.TermMax >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMax)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMax-1)); err != nil {
			return err
		}
	}

	// t.Expiration (abi.ChainEpoch) (int64)
	if t.Expiration >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Expiration)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.Expiration-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *Allocation) UnmarshalCBOR(r io.Reader) (err error) {
	*t = Allocation{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 7 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Client (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Client = abi.ActorID(extra)

	}
	// t.Provider (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Provider = abi.ActorID(extra)

	}
	// t.Data (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Data: %w", err)
		}

		t.Data = c

	}
	// t.Size (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Size = abi.PaddedPieceSize(extra)

	}
	// t.TermMin (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMin = abi.ChainEpoch(extraI)
	}
	// t.TermMax (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMax = abi.ChainEpoch(extraI)
	}
	// t.Expiration (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.Expiration = abi.ChainEpoch(extraI)
	}
	return nil
}

var lengthBufAllocationRequest = []byte{134}

func (t *AllocationRequest) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufAllocationRequest); err != nil {
		return err
	}

	// t.Provider (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Provider)); err != nil {
		return err
	}

	// t.Data (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Data); err != nil {
		return xerrors.Errorf("failed to write cid field t.Data: %w", err)
	}

	// t.Size (abi.PaddedPieceSize) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Size)); err != nil {
		return err
	}

	// t.TermMin (abi.ChainEpoch) (int64)
	if t.TermMin >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMin)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMin-1)); err != nil {
			return err
		}
	}

	// t.TermMax (abi.ChainEpoch) (int64)
	if t.TermMax >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.TermMax)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.TermMax-1)); err != nil {
			return err
		}
	}

	// t.Expiration (abi.ChainEpoch) (int64)
	if t.Expiration >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Expiration)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.Expiration-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *AllocationRequest) UnmarshalCBOR(r io.Reader) (err error) {
	*t = AllocationRequest{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Provider (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Provider = abi.ActorID(extra)

	}
	// t.Data (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Data: %w", err)
		}

		t.Data = c

	}
	// t.Size (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Size = abi.PaddedPieceSize(extra)

	}
	// t.TermMin (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMin = abi.ChainEpoch(extraI)
	}
	// t.TermMax (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.TermMax = abi.ChainEpoch(extraI)
	}
	// t.Expiration (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.Expiration = abi.ChainEpoch(extraI)
	}
	return nil
}

var lengthBufAllocationRequests = []byte{130}

func (t *AllocationRequests) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufAllocationRequests); err != nil {
		return err
	}

	// t.Allocations ([]verifreg.AllocationRequest) (slice)
	if len(t.Allocations) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Allocations was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Allocations))); err != nil {
		return err
	}
	for _, v := range t.Allocations {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}

	// t.Extensions ([]verifreg.ClaimExtensionRequest) (slice)
	if len(t.Extensions) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Extensions was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Extensions))); err != nil {
		return err
	}
	for _, v := range t.Extensions {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *AllocationRequests) UnmarshalCBOR(r io.Reader) (err error) {
	*t = AllocationRequests{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Allocations ([]verifreg.AllocationRequest) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Allocations: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Allocations = make([]AllocationRequest, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v AllocationRequest
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Allocations[i] = v
	}

	// t.Extensions ([]verifreg.ClaimExtensionRequest) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Extensions: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Extensions = make([]ClaimExtensionRequest, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v ClaimExtensionRequest
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Extensions[i] = v
	}

	return nil
}
