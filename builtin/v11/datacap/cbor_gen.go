// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package datacap

import (
	"fmt"
	"io"
	"math"
	"sort"

	address "github.com/filecoin-project/go-address"
	cid "github.com/ipfs/go-cid"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf
var _ = cid.Undef
var _ = math.E
var _ = sort.Sort

var lengthBufState = []byte{130}

func (t *State) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufState); err != nil {
		return err
	}

	// t.Governor (address.Address) (struct)
	if err := t.Governor.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Token (datacap.TokenState) (struct)
	if err := t.Token.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *State) UnmarshalCBOR(r io.Reader) (err error) {
	*t = State{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Governor (address.Address) (struct)

	{

		if err := t.Governor.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Governor: %w", err)
		}

	}
	// t.Token (datacap.TokenState) (struct)

	{

		if err := t.Token.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Token: %w", err)
		}

	}
	return nil
}

var lengthBufTokenState = []byte{132}

func (t *TokenState) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTokenState); err != nil {
		return err
	}

	// t.Supply (big.Int) (struct)
	if err := t.Supply.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Balances (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Balances); err != nil {
		return xerrors.Errorf("failed to write cid field t.Balances: %w", err)
	}

	// t.Allowances (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Allowances); err != nil {
		return xerrors.Errorf("failed to write cid field t.Allowances: %w", err)
	}

	// t.HamtBitWidth (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.HamtBitWidth)); err != nil {
		return err
	}

	return nil
}

func (t *TokenState) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TokenState{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Supply (big.Int) (struct)

	{

		if err := t.Supply.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Supply: %w", err)
		}

	}
	// t.Balances (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Balances: %w", err)
		}

		t.Balances = c

	}
	// t.Allowances (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Allowances: %w", err)
		}

		t.Allowances = c

	}
	// t.HamtBitWidth (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.HamtBitWidth = uint64(extra)

	}
	return nil
}

var lengthBufMintParams = []byte{131}

func (t *MintParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufMintParams); err != nil {
		return err
	}

	// t.To (address.Address) (struct)
	if err := t.To.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Operators ([]address.Address) (slice)
	if len(t.Operators) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Operators was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Operators))); err != nil {
		return err
	}
	for _, v := range t.Operators {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}

	}
	return nil
}

func (t *MintParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = MintParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.To (address.Address) (struct)

	{

		if err := t.To.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.To: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.Operators ([]address.Address) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Operators: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Operators = make([]address.Address, extra)
	}

	for i := 0; i < int(extra); i++ {
		{
			var maj byte
			var extra uint64
			var err error
			_ = maj
			_ = extra
			_ = err

			{

				if err := t.Operators[i].UnmarshalCBOR(cr); err != nil {
					return xerrors.Errorf("unmarshaling t.Operators[i]: %w", err)
				}

			}

		}
	}
	return nil
}

var lengthBufMintReturn = []byte{131}

func (t *MintReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufMintReturn); err != nil {
		return err
	}

	// t.Balance (big.Int) (struct)
	if err := t.Balance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Supply (big.Int) (struct)
	if err := t.Supply.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RecipientData ([]uint8) (slice)
	if len(t.RecipientData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.RecipientData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.RecipientData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.RecipientData); err != nil {
		return err
	}

	return nil
}

func (t *MintReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = MintReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Balance (big.Int) (struct)

	{

		if err := t.Balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Balance: %w", err)
		}

	}
	// t.Supply (big.Int) (struct)

	{

		if err := t.Supply.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Supply: %w", err)
		}

	}
	// t.RecipientData ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.RecipientData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.RecipientData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.RecipientData); err != nil {
		return err
	}

	return nil
}

var lengthBufDestroyParams = []byte{130}

func (t *DestroyParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDestroyParams); err != nil {
		return err
	}

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *DestroyParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DestroyParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufTransferParams = []byte{131}

func (t *TransferParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferParams); err != nil {
		return err
	}

	// t.To (address.Address) (struct)
	if err := t.To.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.OperatorData ([]uint8) (slice)
	if len(t.OperatorData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.OperatorData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.OperatorData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.OperatorData); err != nil {
		return err
	}

	return nil
}

func (t *TransferParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.To (address.Address) (struct)

	{

		if err := t.To.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.To: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.OperatorData ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.OperatorData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.OperatorData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.OperatorData); err != nil {
		return err
	}

	return nil
}

var lengthBufTransferReturn = []byte{131}

func (t *TransferReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferReturn); err != nil {
		return err
	}

	// t.FromBalance (big.Int) (struct)
	if err := t.FromBalance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.ToBalance (big.Int) (struct)
	if err := t.ToBalance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RecipientData ([]uint8) (slice)
	if len(t.RecipientData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.RecipientData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.RecipientData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.RecipientData); err != nil {
		return err
	}

	return nil
}

func (t *TransferReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.FromBalance (big.Int) (struct)

	{

		if err := t.FromBalance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.FromBalance: %w", err)
		}

	}
	// t.ToBalance (big.Int) (struct)

	{

		if err := t.ToBalance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.ToBalance: %w", err)
		}

	}
	// t.RecipientData ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.RecipientData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.RecipientData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.RecipientData); err != nil {
		return err
	}

	return nil
}

var lengthBufTransferFromParams = []byte{132}

func (t *TransferFromParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferFromParams); err != nil {
		return err
	}

	// t.From (address.Address) (struct)
	if err := t.From.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.To (address.Address) (struct)
	if err := t.To.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.OperatorData ([]uint8) (slice)
	if len(t.OperatorData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.OperatorData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.OperatorData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.OperatorData); err != nil {
		return err
	}

	return nil
}

func (t *TransferFromParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferFromParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.From (address.Address) (struct)

	{

		if err := t.From.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.From: %w", err)
		}

	}
	// t.To (address.Address) (struct)

	{

		if err := t.To.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.To: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.OperatorData ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.OperatorData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.OperatorData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.OperatorData); err != nil {
		return err
	}

	return nil
}

var lengthBufTransferFromReturn = []byte{132}

func (t *TransferFromReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferFromReturn); err != nil {
		return err
	}

	// t.FromBalance (big.Int) (struct)
	if err := t.FromBalance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.ToBalance (big.Int) (struct)
	if err := t.ToBalance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Allowance (big.Int) (struct)
	if err := t.Allowance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RecipientData ([]uint8) (slice)
	if len(t.RecipientData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.RecipientData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.RecipientData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.RecipientData); err != nil {
		return err
	}

	return nil
}

func (t *TransferFromReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferFromReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.FromBalance (big.Int) (struct)

	{

		if err := t.FromBalance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.FromBalance: %w", err)
		}

	}
	// t.ToBalance (big.Int) (struct)

	{

		if err := t.ToBalance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.ToBalance: %w", err)
		}

	}
	// t.Allowance (big.Int) (struct)

	{

		if err := t.Allowance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Allowance: %w", err)
		}

	}
	// t.RecipientData ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.RecipientData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.RecipientData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.RecipientData); err != nil {
		return err
	}

	return nil
}

var lengthBufIncreaseAllowanceParams = []byte{130}

func (t *IncreaseAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufIncreaseAllowanceParams); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Increase (big.Int) (struct)
	if err := t.Increase.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *IncreaseAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = IncreaseAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	// t.Increase (big.Int) (struct)

	{

		if err := t.Increase.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Increase: %w", err)
		}

	}
	return nil
}

var lengthBufDecreaseAllowanceParams = []byte{130}

func (t *DecreaseAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDecreaseAllowanceParams); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Decrease (big.Int) (struct)
	if err := t.Decrease.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *DecreaseAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DecreaseAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	// t.Decrease (big.Int) (struct)

	{

		if err := t.Decrease.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Decrease: %w", err)
		}

	}
	return nil
}

var lengthBufRevokeAllowanceParams = []byte{129}

func (t *RevokeAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRevokeAllowanceParams); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RevokeAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RevokeAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	return nil
}

var lengthBufGetAllowanceParams = []byte{130}

func (t *GetAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufGetAllowanceParams); err != nil {
		return err
	}

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *GetAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = GetAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	return nil
}

var lengthBufBurnParams = []byte{129}

func (t *BurnParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnParams); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufBurnReturn = []byte{129}

func (t *BurnReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnReturn); err != nil {
		return err
	}

	// t.Balance (big.Int) (struct)
	if err := t.Balance.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Balance (big.Int) (struct)

	{

		if err := t.Balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Balance: %w", err)
		}

	}
	return nil
}

var lengthBufBurnFromParams = []byte{130}

func (t *BurnFromParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnFromParams); err != nil {
		return err
	}

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnFromParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnFromParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufBurnFromReturn = []byte{130}

func (t *BurnFromReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnFromReturn); err != nil {
		return err
	}

	// t.Balance (big.Int) (struct)
	if err := t.Balance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Allowance (big.Int) (struct)
	if err := t.Allowance.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnFromReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnFromReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Balance (big.Int) (struct)

	{

		if err := t.Balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Balance: %w", err)
		}

	}
	// t.Allowance (big.Int) (struct)

	{

		if err := t.Allowance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Allowance: %w", err)
		}

	}
	return nil
}
